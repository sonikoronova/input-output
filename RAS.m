function [A, err]=RAS(A0, u, v)
    % исходим из следующих предположений
    % А0 - базовая матрица
    % u -- вектор строковых сумм у целевой матрицы
    % v -- вектор стобцовых сумм у целевой матрицы
    % A -- целевая матрица
    % err -- бинарная переменная, отвечающая за ошибку, т.е. если наш метод
    % не сойдется или сломается, то err=1, иначе 0
    
    % дописать чекеры на нулевые строки
    % дописать чекер на равенство  сумм u  и v
    % дописать чекер на много нулей
    
    % инициализируем метод базовой матрицей
    A=A0;
    
    % выпишем порог для условия выхода, о нем ниже
    eps=1e-2;
       
    % условие на некорректные данные u и v
    
%     if abs(sum(u)-sum(v))>eps
%        err=1;
%        disp('Different sums') 
%        return
%     end
    
    % условие на наличие нулевых строк или столбцов
    
    if ismember(0, sum(abs(A0), 1)) || ismember(0, sum(abs(A0), 2))
       err=1;
       disp('Row or column of 0')
       return
    end
    % запустим итерационный процесс
    i=0;
    
    while true
        % Посчитаем суммы в матрице по строкам
        % В матлабе у функции sum есть второй параметр, который говорит, по
        % какому измерению мы считаем; по необъяснимым причинам 1 -- это
        % столбцы, а 2 -- это строки
        A_rows=sum(A,2);
        R=diag(u./A_rows);
        % Команда diag создает новую квадратную матрицы с указанным
        % вектором на диагонали. ./ -- это поэлементное деление двух
        % матриц одинаковой формы
        A=R*A;
  
        %Формально нужно делать шаги по одному, но, чтобы не загружать код
        %ветвлением, давайте делать сразу 2 -- и строковый, и столбцовый
        
        % Аналогично посчитаем столбцовую сумму
        A_cols=sum(A,1);
        S=diag(v./A_cols);
        A=A*S;
        
        % таким образом сделали одну итерацию
        % Теперь поймем, как нам выйти. Выйдем мы, когда достигнем счастья,
        % т.е. у результата будут желаемые суммы u и v по столбцам и строкам.
        % Ну или почти желаемые. Посчитаем теперь наибольшую относительную
        % ошибку от желаемых сумм (будем считать в кумулятивном смысле, так
        % быстрее сойдется).
        error1=max(abs(A_rows-u))/sum(u);
        error2=max(abs(A_cols-v))/sum(v);
        i=i+1;
        
        % посмотрим, как у нас идут дела
        disp(num2str([i,error1,error2]))
        
        % и укажем когда выходить
        if (error1<=eps) && (error2<=eps)
            err=0;
            disp('Success')
            return
            % метод сошелся
        end
        if ((error1>eps) || (error2>eps)) && (i>1000)
            err=1;
            disp('Does not converge')
            return
            % прошло много времени, а метод не сошелся
        end
    end
end